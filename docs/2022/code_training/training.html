<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-06-27 Mon 18:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Leetcode Exercises</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Claudio Parra">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="/assets/style.css">
<link rel="stylesheet" type="text/css" href="/assets/style.css" />
<link rel="stylesheet" type="text/css" href="/assets/htmlize-python.css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Leetcode Exercises</h1>
<nav class="nav">
<ul class="org-ul">
<li><a href="../../../index.html">Back to Home</a></li>
</ul>
</nav>
<div id="outline-container-org621cbb7" class="outline-2">
<h2 id="org621cbb7"><code>[2/2]</code> Day 1</h2>
<div class="outline-text-2" id="text-org621cbb7">
</div>
<div id="outline-container-org70cdce1" class="outline-3">
<h3 id="org70cdce1"><span class="done DONE">DONE</span> Two Sum&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org70cdce1">
<ul class="org-ul">
<li><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></li>
<li>Runtime: O(n) 71%</li>
<li>Memory: O(n) 49%</li>
<li>Notes:
<ul class="org-ul">
<li>Use a dictionary to store potential matches for future numbers.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">twoSum</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>], target: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:
<span class="linenr"> 3: </span>        <span class="org-keyword">if</span> <span class="org-keyword">not</span> nums:
<span class="linenr"> 4: </span>            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"The list 'nums' is empty"</span>)
<span class="linenr"> 5: </span>        <span class="org-string">'''</span>
<span class="linenr"> 6: </span><span class="org-string">        dict with pairs (&lt;number previously found&gt;, &lt;index of that number&gt;)</span>
<span class="linenr"> 7: </span><span class="org-string">        for every number X in nums[], we will lookup this dictionary first to see</span>
<span class="linenr"> 8: </span><span class="org-string">        whether we have seen the value (target-X) before.</span>
<span class="linenr"> 9: </span><span class="org-string">        '''</span>
<span class="linenr">10: </span>        <span class="org-variable-name">wanted</span> = {}
<span class="linenr">11: </span>        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(nums)):
<span class="linenr">12: </span>            <span class="org-variable-name">looking_for</span> = target - nums[j]
<span class="linenr">13: </span>            <span class="org-keyword">if</span> looking_for <span class="org-keyword">in</span> wanted:
<span class="linenr">14: </span>                <span class="org-keyword">return</span>(wanted[looking_for],j)
<span class="linenr">15: </span>            wanted[nums[j]] = j
<span class="linenr">16: </span>        <span class="org-keyword">raise</span> <span class="org-type">Exception</span>(<span class="org-string">"No pair found, you lied to me..."</span>)
<span class="linenr">17: </span>        <span class="org-keyword">return</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc1ac58a" class="outline-3">
<h3 id="orgc1ac58a"><span class="done DONE">DONE</span> Valid Parenthesis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orgc1ac58a">
<ul class="org-ul">
<li><a href="https://leetcode.com/problems/valid-parentheses/">https://leetcode.com/problems/valid-parentheses/</a></li>
<li>Runtime: O(n) 19%</li>
<li>Memory: O(n) 69%</li>
<li>Notes:
<ul class="org-ul">
<li>Use a stack to keep the open parenthesis in order.</li>
<li>if <code>([{</code>, then push. if <code>)]}</code>, check the correspondence and if ok, continue.</li>
<li>Keep the pairs in a dictionary, that makes it easy to maintain.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isValid</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr"> 3: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">openers will contain all the opening parenthesis that are</span>
<span class="linenr"> 4: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">not closed yet.</span>
<span class="linenr"> 5: </span>        <span class="org-variable-name">openers</span> = []
<span class="linenr"> 6: </span>        <span class="org-variable-name">pairs</span> = {<span class="org-string">'('</span>:<span class="org-string">')'</span>, <span class="org-string">'['</span>:<span class="org-string">']'</span>, <span class="org-string">'{'</span>:<span class="org-string">'}'</span>}
<span class="linenr"> 7: </span>        <span class="org-keyword">for</span> par <span class="org-keyword">in</span> s:
<span class="linenr"> 8: </span>            <span class="org-keyword">if</span> par <span class="org-keyword">in</span> <span class="org-string">'([{'</span>:
<span class="linenr"> 9: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">opening, push to stack</span>
<span class="linenr">10: </span>                openers.append(par)
<span class="linenr">11: </span>            <span class="org-keyword">elif</span> openers:
<span class="linenr">12: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">closing AND there is at least one opener in the stack.</span>
<span class="linenr">13: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">check the corresponding opener</span>
<span class="linenr">14: </span>                <span class="org-keyword">if</span> pairs[openers.pop()] != par:
<span class="linenr">15: </span>                    <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr">16: </span>            <span class="org-keyword">else</span>:
<span class="linenr">17: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">closing BUT the stack of openers is empty.</span>
<span class="linenr">18: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">This is a disbalance in the force...</span>
<span class="linenr">19: </span>                <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">at this point nest_stack should be empty, because all parethesis</span>
<span class="linenr">22: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">should have closed with their matching pairs</span>
<span class="linenr">23: </span>        <span class="org-keyword">if</span> openers:
<span class="linenr">24: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr">25: </span>        <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org18fd102" class="outline-2">
<h2 id="org18fd102"><code>[0/2]</code> Day 2</h2>
<div class="outline-text-2" id="text-org18fd102">
</div>
<div id="outline-container-org6dfb610" class="outline-3">
<h3 id="org6dfb610"><span class="todo CURRENT">CURRENT</span> Merge two sorted Lists&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org6dfb610">
<ul class="org-ul">
<li><a href="https://leetcode.com/problems/merge-two-sorted-lists/">https://leetcode.com/problems/merge-two-sorted-lists/</a></li>
<li>Runtime: O(n)</li>
<li>Memory: O(1)</li>
<li>Notes:
<ul class="org-ul">
<li>Check for lists</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">def</span> <span class="org-function-name">mergeTwoLists</span>(<span class="org-keyword">self</span>, list1: Optional[ListNode], \
<span class="linenr"> 9: </span>                      list2: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">if one list is not defined, return the other</span>
<span class="linenr">12: </span>        <span class="org-keyword">if</span> list1 == <span class="org-constant">None</span>:
<span class="linenr">13: </span>            <span class="org-keyword">return</span> list2
<span class="linenr">14: </span>        <span class="org-keyword">elif</span> list2 == <span class="org-constant">None</span>:
<span class="linenr">15: </span>            <span class="org-keyword">return</span> list1
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">both lists exists and have at least one element.</span>
<span class="linenr">18: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">lead_f (front) and lead_r (rear) are two pointers</span>
<span class="linenr">19: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">the beginning of the list with smaller initial value.</span>
<span class="linenr">20: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">front is normally closer to the tail.</span>
<span class="linenr">21: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">other_f and other_r are two pointers to the beginning</span>
<span class="linenr">22: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">of the other list.</span>
<span class="linenr">23: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">result_head is what we will return.</span>
<span class="linenr">24: </span>        <span class="org-keyword">if</span> list1.val &lt; list2.val:
<span class="linenr">25: </span>            <span class="org-variable-name">lead_r</span>,<span class="org-variable-name">other_r</span> = (list1,list2)
<span class="linenr">26: </span>        <span class="org-keyword">else</span>:
<span class="linenr">27: </span>            <span class="org-variable-name">lead_r</span>,<span class="org-variable-name">other_r</span> = (list2,list1)
<span class="linenr">28: </span>        <span class="org-variable-name">result_head</span> = lead_r
<span class="linenr">29: </span>        <span class="org-variable-name">lead_f</span>,<span class="org-variable-name">other_f</span> = lead_r.<span class="org-builtin">next</span>,other_r.<span class="org-builtin">next</span>;
<span class="linenr">30: </span>
<span class="linenr">31: </span>        <span class="org-doc">'''</span>
<span class="linenr">32: </span><span class="org-doc">        1  2  4</span>
<span class="linenr">33: </span><span class="org-doc">        1  3  4</span>
<span class="linenr">34: </span><span class="org-doc">        '''</span>
<span class="linenr">35: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">traverse lists, identifying where to cut lead to</span>
<span class="linenr">36: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">insert parts of other.</span>
<span class="linenr">37: </span>        <span class="org-keyword">while</span> lead_f != <span class="org-constant">None</span> <span class="org-keyword">and</span> other_f != <span class="org-constant">None</span>:
<span class="linenr">38: </span>
<span class="linenr">39: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">move the pair [lead_r,lead_f] forward for as long as</span>
<span class="linenr">40: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">lead_f is smaller than other_r.</span>
<span class="linenr">41: </span>            <span class="org-keyword">while</span> lead_f != <span class="org-constant">None</span> <span class="org-keyword">and</span> lead_f.val &lt; other_r.val:
<span class="linenr">42: </span>                <span class="org-variable-name">lead_r</span> = lead_f
<span class="linenr">43: </span>                <span class="org-variable-name">lead_f</span> = lead_f.<span class="org-builtin">next</span>
<span class="linenr">44: </span>
<span class="linenr">45: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">we found the cutting point in lead: right between</span>
<span class="linenr">46: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">lead_r and lead_f.</span>
<span class="linenr">47: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">Now we find how long is the segment in 'other'</span>
<span class="linenr">48: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">that will be injected into lead.</span>
<span class="linenr">49: </span>
<span class="linenr">50: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">if lead_f is None, then lead_r is the last</span>
<span class="linenr">51: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">element of lead, therefore, we just attach</span>
<span class="linenr">52: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">everything from other at the end of lead; and</span>
<span class="linenr">53: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">we are done.</span>
<span class="linenr">54: </span>            <span class="org-keyword">if</span> lead_f == <span class="org-constant">None</span>:    
<span class="linenr">55: </span>                lead_r.<span class="org-builtin">next</span> = other_r
<span class="linenr">56: </span>                <span class="org-keyword">return</span> result_head
<span class="linenr">57: </span>
<span class="linenr">58: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">try to expand the segment in other by moving other_f</span>
<span class="linenr">59: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">forward for as long as other_f can go before lead_f.</span>
<span class="linenr">60: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">other_m (middle) keeps track of the node before other_f</span>
<span class="linenr">61: </span>            <span class="org-variable-name">other_m</span> = other_r
<span class="linenr">62: </span>            <span class="org-keyword">while</span> other_f != <span class="org-constant">None</span> <span class="org-keyword">and</span> other_f.val &lt;= lead_f.val:
<span class="linenr">63: </span>                <span class="org-variable-name">other_m</span> = other_f
<span class="linenr">64: </span>                <span class="org-variable-name">other_f</span> = other_f.<span class="org-builtin">next</span>
<span class="linenr">65: </span>
<span class="linenr">66: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">other_m is now the last element in the segment</span>
<span class="linenr">67: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">of other that goes between lead_r and lead_f.</span>
<span class="linenr">68: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">Now patch the pointers.</span>
<span class="linenr">69: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">1  2\         /6  7</span>
<span class="linenr">70: </span>            <span class="org-comment-delimiter">#      </span><span class="org-comment">\3  4  5/</span>
<span class="linenr">71: </span>            lead_r.<span class="org-builtin">next</span> = other_r
<span class="linenr">72: </span>            other_m.<span class="org-builtin">next</span> = lead_f
<span class="linenr">73: </span>
<span class="linenr">74: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">if other_f is null, then we are done.</span>
<span class="linenr">75: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">but if lead_f is null AND other_f is still something,</span>
<span class="linenr">76: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">we attach the remainder of other to the end of lead</span>
<span class="linenr">77: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">before exiting.</span>
<span class="linenr">78: </span>            <span class="org-keyword">if</span> other_f == <span class="org-constant">None</span>:
<span class="linenr">79: </span>                <span class="org-keyword">break</span>
<span class="linenr">80: </span>            <span class="org-keyword">if</span> lead_f == <span class="org-constant">None</span>:
<span class="linenr">81: </span>                lead_f.<span class="org-builtin">next</span> = other_f
<span class="linenr">82: </span>                <span class="org-keyword">break</span>
<span class="linenr">83: </span>
<span class="linenr">84: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">if none is null, then there is more work to do.</span>
<span class="linenr">85: </span>            <span class="org-variable-name">lead_r</span>,<span class="org-variable-name">other_r</span> = lead_f,other_f
<span class="linenr">86: </span>            <span class="org-variable-name">lead_f</span>,<span class="org-variable-name">other_f</span> = lead_f.<span class="org-builtin">next</span>,other_f.<span class="org-builtin">next</span>
<span class="linenr">87: </span>        <span class="org-keyword">return</span> result_head
</pre>
</div>
</div>
</div>
<div id="outline-container-org2ccf3aa" class="outline-3">
<h3 id="org2ccf3aa"><span class="todo TODO">TODO</span> Search Insert position&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
</div>
</div>
</div>
</body>
</html>
