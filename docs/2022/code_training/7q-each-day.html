<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-11-03 Thu 19:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seven Questions Each Day!</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Claudio A. Parra">
<meta name="description" content="coding interview, leetcode"
>
<link rel="stylesheet" type="text/css" href="/assets/style.css">
<link rel="stylesheet" type="text/css" href="/assets/htmlize-python.css">
<script src="/assets/ext_links.js" defer></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Seven Questions Each Day!</h1>
<nav id="navbar">
<span id="small-title"></span>
<ul id="nav_list" class="org-ul">
<li><a href="../../../index.html">Back to Home</a></li>
</ul>
</nav>

<script src="/assets/nav.js"></script>

<div id="outline-container-org400d3ce" class="outline-2">
<h2 id="org400d3ce">Day 2: Breaking Inertia</h2>
<div class="outline-text-2" id="text-org400d3ce">
</div>
<div id="outline-container-org867734a" class="outline-3">
<h3 id="org867734a"><span class="done DONE">DONE</span> 7. Validate Binary Search Tree <a href="https://leetcode.com/problems/validate-binary-search-tree/">leetcode 98</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-org867734a">
<ul class="org-ul">
<li>The approach is recursive. The general idea is that each tree returns its own range to its parent. However, if the tree is not a valid Binary Search Tree (BST), then it will return <code>None</code>, instead.</li>
<li>The base case is a terminal tree (leaf node): This is by definition a valid search tree, and its range is just its own value as minimum and maximum.</li>
<li>The recursive case is an intermediate tree (a non-leaf node): If the tree has a left branch, we get the left branch's range:
<ul class="org-ul">
<li>If the returned range is <code>None</code>, then the left tree was invalid: This invalidates also the current tree, so the current tree returns <code>None</code>.</li>
<li>If instead, the returned range is a valid pair of numbers, then we check the relation between the max of the left tree and the own root's value:
<ul class="org-ul">
<li>If the <code>left.max</code> is equal or worst, greater than the root's value, then the BST got just invalidated and we return <code>None</code>.</li>
<li>Otherwise, if <code>left.max</code> is actually strictly less than <code>root.val</code>, then we are good, we just update the minimum on the root's range.</li>
</ul></li>
</ul></li>
<li>The same idea is applied to the right branch of the root.</li>
<li>Eventually, the root will return its own range (or <code>None</code>). And <code>isValidBST()</code> uses that to determine whether the tree is valid or not.</li>
<li>Finally, the problem says that the tree will always have at least one element. But just for the sake of completeness, if somehow <code>isValidBST()</code> receives a <code>root==None</code> tree, I arbitrarily decided that it will be a valid BST.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for a binary tree node.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class TreeNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, left=None, right=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.left = left</span>
<span class="linenr"> 6: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.right = right</span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">class</span> <span class="org-type">Range</span>:
<span class="linenr"> 9: </span>        <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, Min, Max):
<span class="linenr">10: </span>            <span class="org-keyword">self</span>.Min = Min
<span class="linenr">11: </span>            <span class="org-keyword">self</span>.Max = Max
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span class="org-keyword">def</span> <span class="org-function-name">getTreeRange</span>(<span class="org-keyword">self</span>, root: TreeNode) -&gt; Optional[Range]:
<span class="linenr">14: </span>        <span class="org-variable-name">myRange</span> = Range(root.val, root.val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">If the left tree exists, then we test for correctness and update myRange</span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">to reflect the minimum of the whole tree.</span>
<span class="linenr">18: </span>        <span class="org-keyword">if</span> root.left != <span class="org-constant">None</span>:
<span class="linenr">19: </span>            <span class="org-variable-name">branchRange</span> = <span class="org-keyword">self</span>.getTreeRange(root.left)
<span class="linenr">20: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">if the left tree was incorrect, or the max of the left tree is equal</span>
<span class="linenr">21: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">or greater than the root's value, then this tree is not a BST</span>
<span class="linenr">22: </span>            <span class="org-keyword">if</span> branchRange == <span class="org-constant">None</span> <span class="org-keyword">or</span> branchRange.Max &gt;= myRange.Min:
<span class="linenr">23: </span>                <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">24: </span>            <span class="org-variable-name">myRange.Min</span> = branchRange.Min
<span class="linenr">25: </span>
<span class="linenr">26: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">Same idea with the right tree</span>
<span class="linenr">27: </span>        <span class="org-keyword">if</span> root.right != <span class="org-constant">None</span>:
<span class="linenr">28: </span>            <span class="org-variable-name">branchRange</span> = <span class="org-keyword">self</span>.getTreeRange(root.right)
<span class="linenr">29: </span>            <span class="org-keyword">if</span> branchRange == <span class="org-constant">None</span> <span class="org-keyword">or</span> branchRange.Min &lt;= myRange.Max:
<span class="linenr">30: </span>                <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">31: </span>            <span class="org-variable-name">myRange.Max</span> = branchRange.Max
<span class="linenr">32: </span>
<span class="linenr">33: </span>        <span class="org-keyword">return</span> myRange
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isValidBST</span>(<span class="org-keyword">self</span>, root: Optional[TreeNode]) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr">36: </span>        <span class="org-keyword">if</span> root == <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-keyword">self</span>.getTreeRange(root) != <span class="org-constant">None</span>:
<span class="linenr">37: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\): due to the exec. stack</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf63115e" class="outline-3">
<h3 id="orgf63115e"><span class="done DONE">DONE</span> 6. First Bad Version <a href="https://leetcode.com/problems/first-bad-version/">leetcode 278</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orgf63115e">
<ul class="org-ul">
<li>Pretty much a binary search. The only difference with the previous problem is that if you get a "hit", that only means that you <b>could</b> have found what you were looking for (the first bad version), or you are testing some far point after the first occurrence. So there is no early <code>return</code> within the loop.</li>
<li>Another thing, after the <code>while</code> loop, we prefer to return <code>early</code>, if this is bad. Otherwise, the only option is <code>late</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">The isBadVersion API is already defined for you.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">def isBadVersion(version: int) -&gt; bool:</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 5: </span>    <span class="org-keyword">def</span> <span class="org-function-name">firstBadVersion</span>(<span class="org-keyword">self</span>, n: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 6: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">cut halves by checking querying the center</span>
<span class="linenr"> 7: </span>        <span class="org-variable-name">early</span>, <span class="org-variable-name">late</span> = 1, n
<span class="linenr"> 8: </span>        <span class="org-keyword">while</span> early+1 &lt; late:
<span class="linenr"> 9: </span>            <span class="org-variable-name">mid</span> = early + (late-early)//2
<span class="linenr">10: </span>            <span class="org-keyword">if</span> isBadVersion(mid)
<span class="linenr">11: </span>                <span class="org-variable-name">late</span> = mid
<span class="linenr">12: </span>            <span class="org-keyword">else</span>:
<span class="linenr">13: </span>                <span class="org-variable-name">early</span> = mid
<span class="linenr">14: </span>
<span class="linenr">15: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">check edges</span>
<span class="linenr">16: </span>        <span class="org-keyword">if</span> isBadVersion(early):
<span class="linenr">17: </span>            <span class="org-keyword">return</span> early
<span class="linenr">18: </span>        <span class="org-keyword">else</span>:
<span class="linenr">19: </span>            <span class="org-keyword">return</span> late
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(\log{n})\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge01a292" class="outline-3">
<h3 id="orge01a292"><span class="done DONE">DONE</span> 5. Binary Search  <a href="https://leetcode.com/problems/binary-search/">leetcode 704</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orge01a292">
<p>
The devil is in the details. This one is easy, but attention must be put in some corner cases, like:
</p>
<ul class="org-ul">
<li>What if the list is empty (the statement actually guarantees that it will not, though).</li>
<li>What if the value is in some edge (index <code>0</code> or index <code>len(nums)-1</code>).</li>
<li>Can the code generate indices out of bounds?</li>
<li>In python this is not a problem, but in other language (cough cough C) you could incur in an an integer overflow while computing <code>mid</code>. If the array is very very large, then computing <code>(l+r) // 2</code>, in particular <code>l+r</code>, may overflow the size of the integer type, getting esoteric results or lovely <code>Segmentation Fault</code> messages.</li>
</ul>

<p>
Here, <code>l</code> and <code>r</code> are setup in such a way that they always have at least one other element in between, and, if they indeed enter the <code>while</code> loop, they never go out of boundaries.
</p>

<p>
The consequence of the above is that <code>l</code>, <code>m</code>, and <code>r</code>, are always in total order (<code>l &lt; mid &lt; r</code>). That is why the final check after the <code>while</code> loop makes sense.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">search</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>], target: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 3: </span>        <span class="org-keyword">if</span> nums == <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-builtin">len</span>(nums) == 0:
<span class="linenr"> 4: </span>            <span class="org-keyword">return</span> -1
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">check internals by partitioning</span>
<span class="linenr"> 7: </span>        <span class="org-variable-name">l</span>, <span class="org-variable-name">r</span> = 0, <span class="org-builtin">len</span>(nums) - 1
<span class="linenr"> 8: </span>        <span class="org-keyword">while</span> l + 1 &lt; r:
<span class="linenr"> 9: </span>            <span class="org-variable-name">mid</span> = l + (r-l)//2
<span class="linenr">10: </span>            <span class="org-keyword">if</span> target == nums[mid]:
<span class="linenr">11: </span>                <span class="org-keyword">return</span> mid
<span class="linenr">12: </span>            <span class="org-keyword">elif</span> target &lt; nums[mid]:
<span class="linenr">13: </span>                <span class="org-variable-name">r</span> = mid
<span class="linenr">14: </span>            <span class="org-keyword">else</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">target &gt; nums[mid]:</span>
<span class="linenr">15: </span>                <span class="org-variable-name">l</span> = mid
<span class="linenr">16: </span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">check edges</span>
<span class="linenr">18: </span>        <span class="org-keyword">if</span> target == nums[l]:
<span class="linenr">19: </span>            <span class="org-keyword">return</span> l
<span class="linenr">20: </span>        <span class="org-keyword">if</span> target == nums[r]:
<span class="linenr">21: </span>            <span class="org-keyword">return</span> r
<span class="linenr">22: </span>        <span class="org-keyword">return</span> -1
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(\log{n})\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgf63b7dc" class="outline-3">
<h3 id="orgf63b7dc"><span class="done DONE">DONE</span> 4. Binary Tree Level Order Traversal <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode 102</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-orgf63b7dc">
<p>
This problem is very similar to the previous one, but it has two twists:
</p>
<ol class="org-ol">
<li>We descend by levels instead of depth-first</li>
<li>We return a "list of lists": one list per level of the tree.</li>
</ol>

<p>
Let's agree in some names:
</p>
<ul class="org-ul">
<li><b>uncles:</b> the nodes in a given level.</li>
<li><b>children:</b> the descendants of a particular uncle.</li>
<li><b>nephews:</b> all the nodes in the next level.</li>
</ul>

<p>
To solve the first issue, we will <b>use a queue instead of a stack</b>. This changes the traversing direction because each uncle puts their own children <b>behind whatever there is in the queue already</b>. So no nephew is read from the queue until all uncles are read first.
</p>

<p>
To solve the "one list per level" thing, we will, instead of using just one queue, we will use two: <code>uncles</code> and <code>nephews</code>.
</p>
<ol class="org-ol">
<li>Read nodes from <code>uncles</code>.</li>
<li>Append the uncle's value in a list <code>level_vals</code>.</li>
<li>Enqueue this uncle's children to <code>nephews</code>.</li>
<li>Repeat from <b>1.</b></li>
</ol>

<p>
Once <code>uncles</code> becomes empty, that means that <code>level_vals</code> has the values of this level. So:
</p>
<ol class="org-ol">
<li value="5">Append <code>level_vals</code> to the answer list.</li>
<li>Assign a new empty list to the name "<code>level_vals</code>".</li>
<li>Swap the lists' names <code>uncles</code> and <code>nephews</code>, as the first one is empty, and the second one has a full generation of kids on it!</li>
<li>Now start again from <b>1.</b></li>
</ol>

<p>
We finish when, after swapping the names, <code>uncles</code> is empty.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for a binary tree node.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class TreeNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, left=None, right=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.left = left</span>
<span class="linenr"> 6: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.right = right</span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">def</span> <span class="org-function-name">levelOrder</span>(<span class="org-keyword">self</span>, root: Optional[TreeNode]) -&gt; List[List[<span class="org-builtin">int</span>]]:
<span class="linenr"> 9: </span>        <span class="org-keyword">if</span> root == <span class="org-constant">None</span>:
<span class="linenr">10: </span>            <span class="org-keyword">return</span> []
<span class="linenr">11: </span>        <span class="org-variable-name">uncles</span> = [root]
<span class="linenr">12: </span>        <span class="org-variable-name">answer</span> = []
<span class="linenr">13: </span>        <span class="org-keyword">while</span> <span class="org-builtin">len</span>(uncles) &gt; 0:
<span class="linenr">14: </span>            <span class="org-variable-name">nephews</span> = []
<span class="linenr">15: </span>            <span class="org-variable-name">level_vals</span> = []
<span class="linenr">16: </span>
<span class="linenr">17: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">passing through one generation.</span>
<span class="linenr">18: </span>            <span class="org-keyword">while</span> <span class="org-builtin">len</span>(uncles) &gt; 0:
<span class="linenr">19: </span>                <span class="org-variable-name">dady</span> = uncles.pop(0)
<span class="linenr">20: </span>                level_vals.append(dady.val)
<span class="linenr">21: </span>                <span class="org-keyword">if</span> dady.left != <span class="org-constant">None</span>:
<span class="linenr">22: </span>                    nephews.append(dady.left)
<span class="linenr">23: </span>                <span class="org-keyword">if</span> dady.right != <span class="org-constant">None</span>:
<span class="linenr">24: </span>                    nephews.append(dady.right)
<span class="linenr">25: </span>            answer.append(level_vals)
<span class="linenr">26: </span>            <span class="org-variable-name">uncles</span>, <span class="org-variable-name">nephews</span> = nephews, uncles
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span class="org-keyword">return</span> answer
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga442e9e" class="outline-3">
<h3 id="orga442e9e"><span class="done DONE">DONE</span> 3. N-ary Tree Pre-order Traversal <a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">leetcode 589</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orga442e9e">
</div>
<div id="outline-container-org84614bd" class="outline-4">
<h4 id="org84614bd">Recursive Solution</h4>
<div class="outline-text-4" id="text-org84614bd">
<ul class="org-ul">
<li>The recursive approach is not difficult to obtain, however, there are some little interesting aspects.</li>
<li>I could have just used <code>preorder()</code> as a recursive function, but I defined a new one called <code>preorder_rec()</code>, this is because of the return value: If I used the original function, then each level will have to collect the work of their children and extend their own result with the bits obtained from the children.</li>
<li>That is unnecessary. Instead, a unique list <code>preorder_list</code> can be created as a <code>Solution</code>'s class member, so each level can directly access it.</li>
<li>Additionally, we could start with a list of at least 1000 elements, so the array doesn't have to be updated every time a new element is inserted. The upside of this is gaining some speed, the downside is that even if the tree has 1 node, the code will reserve a list for 1000 values, which may be a waste. Choose your flavor&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-doc">"""</span>
<span class="linenr"> 2: </span><span class="org-doc"># Definition for a Node.</span>
<span class="linenr"> 3: </span><span class="org-doc">class Node:</span>
<span class="linenr"> 4: </span><span class="org-doc">    def __init__(self, val=None, children=None):</span>
<span class="linenr"> 5: </span><span class="org-doc">        self.val = val</span>
<span class="linenr"> 6: </span><span class="org-doc">        self.children = children</span>
<span class="linenr"> 7: </span><span class="org-doc">"""</span>
<span class="linenr"> 8: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 9: </span>    <span class="org-comment-delimiter"># </span><span class="org-comment">Recursive Solution</span>
<span class="linenr">10: </span>    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>):
<span class="linenr">11: </span>        <span class="org-keyword">self</span>.preorder_list = []*1000
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span class="org-keyword">def</span> <span class="org-function-name">preorder_rec</span>(<span class="org-keyword">self</span>, root: <span class="org-string">'Node'</span>) -&gt; <span class="org-constant">None</span>:
<span class="linenr">14: </span>        <span class="org-keyword">self</span>.preorder_list.append(root.val)
<span class="linenr">15: </span>        <span class="org-keyword">for</span> c <span class="org-keyword">in</span> root.children:
<span class="linenr">16: </span>            <span class="org-keyword">self</span>.preorder_rec(c)
<span class="linenr">17: </span>        <span class="org-keyword">return</span>
<span class="linenr">18: </span>
<span class="linenr">19: </span>    <span class="org-keyword">def</span> <span class="org-function-name">preorder</span>(<span class="org-keyword">self</span>, root: <span class="org-string">'Node'</span>) -&gt; List[<span class="org-builtin">int</span>]:
<span class="linenr">20: </span>        <span class="org-keyword">if</span> root != <span class="org-constant">None</span>:
<span class="linenr">21: </span>            <span class="org-keyword">self</span>.preorder_rec(root)
<span class="linenr">22: </span>        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.preorder_list
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Runtime</td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left">Memory</td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc3180a7" class="outline-4">
<h4 id="orgc3180a7">Iterative Solution</h4>
<div class="outline-text-4" id="text-orgc3180a7">
<ul class="org-ul">
<li>A stack is created to store nodes. The first to put is the root.</li>
<li>This is the algorithm:
<ol class="org-ol">
<li>Pop a node from the stack (into <code>curr_node</code>).</li>
<li>Save its value on the list to be returned.</li>
<li>Take its children and push them to the queue <b>in reversed order</b>.</li>
<li>Repeat from step 1.</li>
</ol></li>
<li>By doing this, we always "go down" following the child of the child of the child&#x2026;. of the first node. This is effectively a depth-first search.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-doc">"""</span>
<span class="linenr"> 2: </span><span class="org-doc"># Definition for a Node.</span>
<span class="linenr"> 3: </span><span class="org-doc">class Node:</span>
<span class="linenr"> 4: </span><span class="org-doc">    def __init__(self, val=None, children=None):</span>
<span class="linenr"> 5: </span><span class="org-doc">        self.val = val</span>
<span class="linenr"> 6: </span><span class="org-doc">        self.children = children</span>
<span class="linenr"> 7: </span><span class="org-doc">"""</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr">10: </span>    <span class="org-comment-delimiter"># </span><span class="org-comment">Iterative Solution</span>
<span class="linenr">11: </span>    <span class="org-keyword">def</span> <span class="org-function-name">preorder</span>(<span class="org-keyword">self</span>, root: <span class="org-string">'Node'</span>) -&gt; List[<span class="org-builtin">int</span>]:
<span class="linenr">12: </span>        <span class="org-keyword">if</span> root == <span class="org-constant">None</span>:
<span class="linenr">13: </span>            <span class="org-keyword">return</span> []
<span class="linenr">14: </span>        <span class="org-variable-name">expansion_stack</span> = [root]
<span class="linenr">15: </span>        <span class="org-variable-name">preorder_list</span> = []
<span class="linenr">16: </span>        <span class="org-keyword">while</span> <span class="org-builtin">len</span>(expansion_stack) &gt; 0:
<span class="linenr">17: </span>            <span class="org-variable-name">curr_node</span> = expansion_stack.pop()
<span class="linenr">18: </span>            preorder_list.append(curr_node.val)
<span class="linenr">19: </span>            expansion_stack.extend(<span class="org-builtin">reversed</span>(curr_node.children))
<span class="linenr">20: </span>
<span class="linenr">21: </span>        <span class="org-keyword">return</span> preorder_list
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgbe81025" class="outline-3">
<h3 id="orgbe81025"><span class="done DONE">DONE</span> 2. Longest Palindrome <a href="https://leetcode.com/problems/longest-palindrome/">leetcode 409</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orgbe81025">
<ul class="org-ul">
<li>Just count the pairs found (I use a set for that).</li>
<li>If the character has not been seen before, add it. If it is in the set, (it has been seen before), then increment the <code>pairs_found</code> counter, and remove the character from the set.</li>
<li>At the end, you have <code>pairs_found</code> pairs of characters to make your biggest palindrome, <b>BUT</b> remember that palindromes can also have a unique character in the very center. So check if there is any element in the set, If so, one can use any of them to put in the center. If the set is empty, then there is no character left to put in the center.</li>
<li>Finally, return <code>2 * pairs_found + center_char</code>, where <code>center_char</code> is 1 or 0.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">longestPalindrome</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">char_pairs</span> = <span class="org-builtin">set</span>()
<span class="linenr"> 4: </span>        <span class="org-variable-name">pairs_found</span> = 0
<span class="linenr"> 5: </span>        <span class="org-keyword">for</span> c <span class="org-keyword">in</span> s:
<span class="linenr"> 6: </span>            <span class="org-keyword">if</span> c <span class="org-keyword">in</span> char_pairs:
<span class="linenr"> 7: </span>                <span class="org-variable-name">pairs_found</span> += 1
<span class="linenr"> 8: </span>                char_pairs.remove(c)
<span class="linenr"> 9: </span>            <span class="org-keyword">else</span>:
<span class="linenr">10: </span>                char_pairs.add(c)
<span class="linenr">11: </span>        <span class="org-variable-name">center_char</span> = 1 <span class="org-keyword">if</span> <span class="org-builtin">len</span>(char_pairs) &gt; 0 <span class="org-keyword">else</span> 0
<span class="linenr">12: </span>
<span class="linenr">13: </span>        <span class="org-keyword">return</span> 2 * pairs_found + center_char
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4105aa6" class="outline-3">
<h3 id="org4105aa6"><span class="done DONE">DONE</span> 1. Best Time to Buy and Sell Stock <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode 121</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org4105aa6">
<ul class="org-ul">
<li>This is greedy: the idea is to traverse the array and keep track of the smallest price <b>so far</b>, and to check what would the profit be if I sell the stock <b>today</b>.</li>
<li>More precisely, we initialize the variables <code>best_buy</code> and <code>best_profit</code> with their worst possible values.</li>
<li>Then we just run through the list reading one element <code>day_price</code> at the time:
<ol class="org-ol">
<li>If <code>day_price</code> is smaller than the minimum seen so far, then update the minimum registered.</li>
<li>If, instead, <code>day_price</code> is <b>NOT</b> smaller, then we don't attempt to update <code>best_buy</code>, instead, there is profit if we sell today. So we check whether selling today <b>would</b> yield a better profit than what we have seen so far. If so, then update your <code>best_profit</code>, otherwise, keep the current.</li>
<li>After doing this test, and perhaps update, just get the next element and repeat from (1.).</li>
</ol></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">maxProfit</span>(<span class="org-keyword">self</span>, prices: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">best_buy</span> = <span class="org-builtin">float</span>(<span class="org-string">'inf'</span>)
<span class="linenr"> 4: </span>        <span class="org-variable-name">best_profit</span> = 0
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>        <span class="org-keyword">for</span> day_price <span class="org-keyword">in</span> prices:
<span class="linenr"> 7: </span>            <span class="org-keyword">if</span> day_price &lt; best_buy:
<span class="linenr"> 8: </span>                <span class="org-variable-name">best_buy</span> = day_price
<span class="linenr"> 9: </span>            <span class="org-keyword">elif</span> (day_price - best_buy) &gt; best_profit:
<span class="linenr">10: </span>                <span class="org-variable-name">best_profit</span> = day_price - best_buy
<span class="linenr">11: </span>        <span class="org-keyword">return</span> best_profit
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org7ff9171" class="outline-2">
<h2 id="org7ff9171">Day 1: Let's go!</h2>
<div class="outline-text-2" id="text-org7ff9171">
</div>
<div id="outline-container-org24e504c" class="outline-3">
<h3 id="org24e504c"><span class="done DONE">DONE</span> 7. Linked List Cycle II <a href="https://leetcode.com/problems/linked-list-cycle-ii">leetcode 142</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-org24e504c">
<ul class="org-ul">
<li>This Problem uses <a href="https://youcademy.org/floyds-tortise-hare-algorithm/">Floyd's "Tortise and Hare"</a> Cycle finding algorithm.</li>
<li>Basically, we put two pointers "slow" and "fast" at the <b>same</b> location: <code>head</code>.</li>
<li>Slow advances one node at the time, and Fast advances two. (Be careful with de-referencing <code>None</code> pointers).</li>
<li>If there is no loop, then the fast pointer will find that its own <code>next</code> node is <code>None</code>. Fast pointer will see this before the slow pointer.</li>
<li>But, as the algorithm states, if for a second time (the first was in <code>head</code>) slow and fast are in the same spot, then there <b>must</b> be a cycle. It is quite intuitive.</li>
<li>The second part of the algorithm is more interesting, it states that: if you put a pointer <code>p1</code> at the meeting point between fast and slow, and another <code>p2</code> at <code>head</code>, and make both of them advance one node at the time, they will meet at the entrance of the loop. Always!</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, x):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = x</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">def</span> <span class="org-function-name">detectCycle</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 9: </span>        <span class="org-variable-name">slow_ptr</span> = <span class="org-variable-name">fast_ptr</span> = head
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">If a pointer reaches None, then the list has an exit, so no loops.</span>
<span class="linenr">12: </span>        <span class="org-keyword">while</span> fast_ptr != <span class="org-constant">None</span> \
<span class="linenr">13: </span>              <span class="org-keyword">and</span> fast_ptr.<span class="org-builtin">next</span> != <span class="org-constant">None</span>:
<span class="linenr">14: </span>            <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">15: </span>            <span class="org-variable-name">fast_ptr</span> = fast_ptr.<span class="org-builtin">next</span>.<span class="org-builtin">next</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">If fast_ptr catches slow_ptr from behind, then there must be a loop.</span>
<span class="linenr">18: </span>            <span class="org-keyword">if</span> slow_ptr == fast_ptr:
<span class="linenr">19: </span>                <span class="org-keyword">break</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">if while loop ended because of end-of-list, then there is no loop.</span>
<span class="linenr">22: </span>        <span class="org-keyword">if</span> fast_ptr == <span class="org-constant">None</span> <span class="org-keyword">or</span> fast_ptr.<span class="org-builtin">next</span> == <span class="org-constant">None</span>:
<span class="linenr">23: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">24: </span>
<span class="linenr">25: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">Otherwise, there is a loop!! Now find the entrance to it.</span>
<span class="linenr">26: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">There is no need to check for None because we already know that</span>
<span class="linenr">27: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">there is no end in this list.</span>
<span class="linenr">28: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">This will not be an infinite loop because of math! the pointers</span>
<span class="linenr">29: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">are guaranteed to meet at the entrance.</span>
<span class="linenr">30: </span>        <span class="org-variable-name">slow_ptr2</span> = head
<span class="linenr">31: </span>        <span class="org-keyword">while</span> slow_ptr != slow_ptr2:
<span class="linenr">32: </span>            <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">33: </span>            <span class="org-variable-name">slow_ptr2</span> = slow_ptr2.<span class="org-builtin">next</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span>        <span class="org-keyword">return</span> slow_ptr
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0a73da8" class="outline-3">
<h3 id="org0a73da8"><span class="done DONE">DONE</span> 6. Middle of the Linked List <a href="https://leetcode.com/problems/middle-of-the-linked-list">leetcode 876</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org0a73da8">
<ul class="org-ul">
<li>In a while loop, I make two pointers run through the list.</li>
<li><code>fast_ptr</code> moves to the next in every loop, and <code>slow_ptr</code> does it only in odd loops (first loop is odd).</li>
<li>It is important to move <code>slow_ptr</code> <b>in odd rather than even loops</b>, because if the list has an even number of elements, moving <code>slow_ptr</code> only in even loops, would give us the first of the two middle nodes.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">middleNode</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 8: </span>        <span class="org-keyword">if</span> head == <span class="org-constant">None</span>:
<span class="linenr"> 9: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">10: </span>        <span class="org-variable-name">slow_ptr</span> = <span class="org-variable-name">fast_ptr</span> = head
<span class="linenr">11: </span>        <span class="org-variable-name">odd_loop</span> = <span class="org-constant">True</span>
<span class="linenr">12: </span>        <span class="org-keyword">while</span> fast_ptr.<span class="org-builtin">next</span> != <span class="org-constant">None</span>:
<span class="linenr">13: </span>            <span class="org-variable-name">fast_ptr</span> = fast_ptr.<span class="org-builtin">next</span>
<span class="linenr">14: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">move slow_ptr only in odd loops</span>
<span class="linenr">15: </span>            <span class="org-keyword">if</span> odd_loop:
<span class="linenr">16: </span>                <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">17: </span>            <span class="org-variable-name">odd_loop</span> = <span class="org-keyword">not</span> odd_loop
<span class="linenr">18: </span>        <span class="org-keyword">return</span> slow_ptr
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga87fa95" class="outline-3">
<h3 id="orga87fa95"><span class="done DONE">DONE</span> 5. Reverse Linked List <a href="https://leetcode.com/problems/reverse-linked-list">leetcode 206</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orga87fa95">
<ul class="org-ul">
<li>Let's think about the original list as something like this: <code>a--&gt; b--&gt; ... m--&gt; n--&gt; ... --&gt; None</code>.</li>
<li>This list will be divided in two partitions: The Original list (<code>orig_head</code>), and the New list (<code>new_list</code>). The Original will shrink removing one element at the time from its beginning. The New will grow adding one element at the time to its beginning.</li>
<li>At some point the lists will look like this: New: <code>None &lt;--a &lt;--b &lt;--c ... &lt;--m</code>. Original: <code>n--&gt; o--&gt; p--&gt; ... --&gt; None</code>.</li>
<li>Note that the assignment before looping <code>new_head.next = None</code> is to signal the end of the new list.</li>
<li>In the loop, if <code>orig_head</code> is <code>None</code>, this means that we reached the end of the original list, therefore, the reversing is done, and already attached to <code>new_head=</code>.</li>
<li>But if <code>orig_head</code> actually is a node, then we take that node and put it at the beginning of the new list.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">reverseList</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 8: </span>        <span class="org-keyword">if</span> head == <span class="org-constant">None</span>:
<span class="linenr"> 9: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-variable-name">new_head</span> = head
<span class="linenr">12: </span>        <span class="org-variable-name">orig_head</span> = head.<span class="org-builtin">next</span> <span class="org-comment-delimiter"># </span><span class="org-comment">maybe None</span>
<span class="linenr">13: </span>        new_head.<span class="org-builtin">next</span> = <span class="org-constant">None</span> <span class="org-comment-delimiter"># </span><span class="org-comment">the ending of the new list</span>
<span class="linenr">14: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh    h--&gt; ...--&gt; None</span>
<span class="linenr">15: </span>        <span class="org-keyword">while</span> orig_head != <span class="org-constant">None</span>:
<span class="linenr">16: </span>            <span class="org-variable-name">temp_head</span> = orig_head
<span class="linenr">17: </span>            <span class="org-variable-name">orig_head</span> = orig_head.<span class="org-builtin">next</span> <span class="org-comment-delimiter"># </span><span class="org-comment">maybe None</span>
<span class="linenr">18: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh   th--&gt; h--&gt; ...--&gt; None</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span>            temp_head.<span class="org-builtin">next</span> = new_head
<span class="linenr">21: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh &lt;--th    h--&gt; ...--&gt; None</span>
<span class="linenr">22: </span>
<span class="linenr">23: </span>            <span class="org-variable-name">new_head</span> = temp_head
<span class="linenr">24: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--?? &lt;--nh    h--&gt; ...--&gt; None</span>
<span class="linenr">25: </span>
<span class="linenr">26: </span>        <span class="org-keyword">return</span> new_head
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4b2963c" class="outline-3">
<h3 id="org4b2963c"><span class="done DONE">DONE</span> 4. Merge Two Sorted Lists <a href="https://leetcode.com/problems/merge-two-sorted-lists">leetcode 21</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org4b2963c">
<ol class="org-ol">
<li>Out of the two lists <code>list1</code> and <code>list2</code>, we put the one that starts smallest in <code>list_runner</code>, and the other in <code>list_insert</code>.</li>
<li>We walk through <code>list_runner</code> and stop when the pointer is on
the last element smaller or equal than the one on <code>list_insert</code>.</li>
<li>We create an <code>after_cut</code> pointer to the next one in <code>list_runner</code>, and insert the whole <code>list_insert</code> at <code>list_runner.next</code>.</li>
<li>Now we use <code>list_insert</code> as the new <code>list_runner</code>, and <code>after_cut</code> as the new <code>list_insert</code>.</li>
<li>We repeat the steps from <b>2.</b></li>
<li>Considerations and corner-cases:
<ol class="org-ol">
<li>If one of the lists is empty, then the work is trivial: the other list is the solution.</li>
<li>If we walk to the very end of <code>list_runner</code> (as in step <b>2.</b>), whatever is reminder from <code>list_insert</code>, is appended at the end of <code>list_runner</code></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">mergeTwoLists</span>(<span class="org-keyword">self</span>,
<span class="linenr"> 8: </span>                      list1: Optional[ListNode], \
<span class="linenr"> 9: </span>                      list2: Optional[ListNode]) \
<span class="linenr">10: </span>                      -&gt; Optional[ListNode]:
<span class="linenr">11: </span>        <span class="org-keyword">if</span> list1 == <span class="org-constant">None</span>:
<span class="linenr">12: </span>            <span class="org-keyword">return</span> list2
<span class="linenr">13: </span>        <span class="org-keyword">if</span> list2 == <span class="org-constant">None</span>:
<span class="linenr">14: </span>            <span class="org-keyword">return</span> list1
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">let list1 be the one with the smallest (or equal) starting</span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">value out of the two lists.</span>
<span class="linenr">18: </span>        <span class="org-variable-name">list_runner</span>,<span class="org-variable-name">list_insert</span> = (list1,list2) \
<span class="linenr">19: </span>            <span class="org-keyword">if</span> list1.val &lt; list2.val \
<span class="linenr">20: </span>               <span class="org-keyword">else</span> (list2,list1)
<span class="linenr">21: </span>        <span class="org-variable-name">ans</span> = list_runner
<span class="linenr">22: </span>
<span class="linenr">23: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">breaks when there is nothing else to insert in list_runner.</span>
<span class="linenr">24: </span>        <span class="org-keyword">while</span> list_insert != <span class="org-constant">None</span>:
<span class="linenr">25: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_runner points to its furthest element smaller or equal</span>
<span class="linenr">26: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">than value at list_insert. After this while loop, list_runner</span>
<span class="linenr">27: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">is at the end of its contiguous segment. Between</span>
<span class="linenr">28: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_runner and list_runner.next, a portion of list_insert</span>
<span class="linenr">29: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">will be inserted.</span>
<span class="linenr">30: </span>            <span class="org-keyword">while</span> list_runner.<span class="org-builtin">next</span> != <span class="org-constant">None</span> <span class="org-keyword">and</span> \
<span class="linenr">31: </span>                  list_runner.<span class="org-builtin">next</span>.val &lt;= list_insert.val:
<span class="linenr">32: </span>                <span class="org-variable-name">list_runner</span> = list_runner.<span class="org-builtin">next</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">means that we reached the end of list_runner and still the</span>
<span class="linenr">35: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">last element was smaller or equal than the current in</span>
<span class="linenr">36: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_insert. Therefore, we just append the whole list_insert</span>
<span class="linenr">37: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">at the end of list_runner.</span>
<span class="linenr">38: </span>            <span class="org-keyword">if</span> list_runner.<span class="org-builtin">next</span> == <span class="org-constant">None</span>:
<span class="linenr">39: </span>                list_runner.<span class="org-builtin">next</span> = list_insert
<span class="linenr">40: </span>                <span class="org-keyword">break</span>
<span class="linenr">41: </span>
<span class="linenr">42: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;lr&#8213;&#8213;lrac&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">43: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">44: </span>            <span class="org-variable-name">list_runner_after_cut</span> = list_runner.<span class="org-builtin">next</span>
<span class="linenr">45: </span>
<span class="linenr">46: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;lr&#9488; lrac&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">47: </span>            <span class="org-comment-delimiter">#           </span><span class="org-comment">&#9492;&#8213;li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">48: </span>            list_runner.<span class="org-builtin">next</span> = list_insert
<span class="linenr">49: </span>
<span class="linenr">50: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#9488; li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">51: </span>            <span class="org-comment-delimiter">#           </span><span class="org-comment">&#9492;&#8213;lr&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">52: </span>            <span class="org-variable-name">list_runner</span>,<span class="org-variable-name">list_insert</span> = list_insert,list_runner_after_cut
<span class="linenr">53: </span>
<span class="linenr">54: </span>        <span class="org-keyword">return</span> ans
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org87ba8cf" class="outline-3">
<h3 id="org87ba8cf"><span class="done DONE">DONE</span> 3. Is Sub-sequence <a href="https://leetcode.com/problems/is-subsequence/">leetcode 392</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org87ba8cf">
<ul class="org-ul">
<li><del>Here I am thinking that if many sub-sequences <code>s</code> are going to be searched in the same <code>t</code> then it may be a good idea to make a dictionary with "the first occurrence of each character of <code>t</code>", then, each subsequent search would be just checking that the indices obtained from the dictionary go in ascending order&#x2026; hold on&#x2026; This does not handle repetitions. Scratch that.</del></li>
<li>I will grab the first char of the sub-sequence candidate <code>s</code>, and start traversing <code>t</code>. If I find my character, then I grab the next one in <code>s</code>, and keep searching starting from the very next one in <code>t</code>.</li>
<li>There are some special cases:
<ul class="org-ul">
<li>If <code>s</code> is empty, then it is always a sub-sequence.</li>
<li>If <code>t</code> is empty, then only <code>s=""</code> is sub-sequence.</li>
<li>If <code>len(s)&gt;len(t)</code>, then <code>s</code> cannot be sub-sequence of <code>t</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isSubsequence</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr"> 3: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">corner cases</span>
<span class="linenr"> 4: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(s) == 0:
<span class="linenr"> 5: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
<span class="linenr"> 6: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t) &lt; <span class="org-builtin">len</span>(s):
<span class="linenr"> 7: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">to indices traverse s and t</span>
<span class="linenr">10: </span>        <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> = 0, 0
<span class="linenr">11: </span>        <span class="org-keyword">while</span> (i &lt; <span class="org-builtin">len</span>(s) <span class="org-keyword">and</span> j &lt; <span class="org-builtin">len</span>(t)):
<span class="linenr">12: </span>            <span class="org-keyword">if</span> (s[i] == t[j]):
<span class="linenr">13: </span>                <span class="org-variable-name">i</span> += 1
<span class="linenr">14: </span>            <span class="org-variable-name">j</span> += 1
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">check if the s was totally covered</span>
<span class="linenr">17: </span>        <span class="org-keyword">if</span> (i == <span class="org-builtin">len</span>(s)):
<span class="linenr">18: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
<span class="linenr">19: </span>        <span class="org-keyword">else</span>:
<span class="linenr">20: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org86c4a64" class="outline-3">
<h3 id="org86c4a64"><span class="done DONE">DONE</span> 2. Isomorphic Strings <a href="https://leetcode.com/problems/isomorphic-strings/">leetcode 205</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org86c4a64">
<ul class="org-ul">
<li>Here I am using a "bilingual" dictionary (<code>forward_dict</code> for \(s \rightarrow t\), and <code>backward_dict</code> for \(t \rightarrow s\).</li>
<li>The idea is that if a character <code>si</code> maps to <code>ti</code> in <code>forward_dict</code>, then <code>backward_dict</code> must have a mapping from <code>ti</code> to <code>si</code>, and vice versa.</li>
<li>If a mapping is not found, and because it is factual that <code>si</code> \(\leftrightarrow\) <code>ti</code>, then each mapping is added to its corresponding dictionary.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isIsomorphic</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">forward_dict</span> = {}
<span class="linenr"> 4: </span>        <span class="org-variable-name">backward_dict</span> = {}
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">diff lenghth breaks isomorphism.</span>
<span class="linenr"> 7: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(s) != <span class="org-builtin">len</span>(t):
<span class="linenr"> 8: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">It must be that: si -&gt; ti and ti -&gt; si</span>
<span class="linenr">11: </span>        <span class="org-keyword">for</span> si,ti <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(s,t):
<span class="linenr">12: </span>            <span class="org-keyword">if</span> si <span class="org-keyword">in</span> forward_dict:
<span class="linenr">13: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">if si-&gt;tj, then si-&gt;ti and si-&gt;tj; not isomorphic</span>
<span class="linenr">14: </span>                <span class="org-keyword">if</span> forward_dict[si] != ti:
<span class="linenr">15: </span>                    <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr">16: </span>            <span class="org-keyword">else</span>:
<span class="linenr">17: </span>                <span class="org-variable-name">forward_dict</span>[si] = ti
<span class="linenr">18: </span>
<span class="linenr">19: </span>            <span class="org-keyword">if</span> ti <span class="org-keyword">in</span> backward_dict:
<span class="linenr">20: </span>                <span class="org-keyword">if</span> backward_dict[ti] != si:
<span class="linenr">21: </span>                    <span class="org-keyword">return</span> <span class="org-constant">False</span>  
<span class="linenr">22: </span>            <span class="org-keyword">else</span>:
<span class="linenr">23: </span>                <span class="org-variable-name">backward_dict</span>[ti] = si
<span class="linenr">24: </span>        <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org59b6e25" class="outline-3">
<h3 id="org59b6e25"><span class="done DONE">DONE</span> 1. Find Pivot Index <a href="https://leetcode.com/problems/find-pivot-index/">leetcode 724</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org59b6e25">
<ul class="org-ul">
<li>An idea that leads to \(O(n)\) exec. time is to add-up everything in a variable <code>total</code>, so we know what is the total sum of the whole array <code>nums</code>.</li>
<li>Then, go back to the beginning and traverse one by one and carrying a <code>left_sum</code> initialized in 0 .</li>
<li>In each iteration, I compute <code>right_sum = total - left_sum - nums[i]</code> and check if <code>left_sum</code> is equal to <code>right_sum</code>.</li>
<li>If they are equal, I return the index. If not, the pivot candidate <code>arr[i]</code> is added to <code>left_sum</code>.</li>
<li>The numbers can be negative, so even if <code>left_sum</code> becomes bigger than <code>right_sum</code>, there is still a chance of going back to a balanced state.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">pivotIndex</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">total</span> = <span class="org-builtin">sum</span>(nums)
<span class="linenr"> 4: </span>        <span class="org-variable-name">left_sum</span> = 0
<span class="linenr"> 5: </span>        <span class="org-keyword">for</span> i,piv <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(nums):
<span class="linenr"> 6: </span>            <span class="org-variable-name">right_sum</span> = total - left_sum - piv
<span class="linenr"> 7: </span>            <span class="org-keyword">if</span> left_sum == right_sum:
<span class="linenr"> 8: </span>                <span class="org-keyword">return</span> i
<span class="linenr"> 9: </span>            <span class="org-variable-name">left_sum</span> += piv
<span class="linenr">10: </span>        <span class="org-keyword">return</span> -1
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org4332647" class="outline-2">
<h2 id="org4332647">Day 0: Get your lazy ass started!</h2>
<div class="outline-text-2" id="text-org4332647">
</div>
<div id="outline-container-org892197f" class="outline-3">
<h3 id="org892197f"><span class="done DONE">DONE</span> 1. Running Sum of 1d Array <a href="https://leetcode.com/problems/running-sum-of-1d-array/">leetcode 1480</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org892197f">
<ul class="org-ul">
<li>Easy warm-up, carry the sum in a variable <code>last_sum</code>, and in every iteration, put its current value in the array to return.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr">2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">runningSum</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>]) -&gt; List[<span class="org-builtin">int</span>]:
<span class="linenr">3: </span>        <span class="org-variable-name">rsum</span> = []
<span class="linenr">4: </span>        <span class="org-variable-name">last_sum</span> = 0
<span class="linenr">5: </span>        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> nums:
<span class="linenr">6: </span>            <span class="org-variable-name">last_sum</span> += x
<span class="linenr">7: </span>            rsum.append(last_sum)
<span class="linenr">8: </span>        <span class="org-keyword">return</span> rsum
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>

<tr>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Claudio A. Parra</p>
<p class="email">Email: <a href="mailto:onlycparra at gm*il d0t c*m">onlycparra at gm*il d0t c*m</a></p>
<p class="date">Created: 2022-11-03 Thu 19:44</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
