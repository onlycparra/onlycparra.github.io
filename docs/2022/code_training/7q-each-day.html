<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-11-01 Tue 00:03 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seven Questions Each Day!</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Claudio A. Parra">
<meta name="description" content="coding interview, leetcode"
>
<link rel="stylesheet" type="text/css" href="/assets/style.css">
<link rel="stylesheet" type="text/css" href="/assets/htmlize-python.css">
<script src="/assets/ext_links.js" defer></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Seven Questions Each Day!</h1>
<nav id="navbar">
<span id="small-title"></span>
<ul id="nav_list" class="org-ul">
<li><a href="../../../index.html">Back to Home</a></li>
</ul>
</nav>

<script src="/assets/nav.js"></script>

<div class="outline-2"><div class="outline-text-2"><p>
<p>
This is an attempt to compress the <a href="75days.html">75 Days Coding Program</a> of Leetcode in just 21 days. To get that done, I should do 7 problems every day!!
</p>
</p></div></div>

<div id="outline-container-orgb7a5a18" class="outline-2">
<h2 id="orgb7a5a18">Day 2</h2>
<div class="outline-text-2" id="text-orgb7a5a18">
</div>
<div id="outline-container-orgd70f89f" class="outline-3">
<h3 id="orgd70f89f"><span class="done DONE">DONE</span> 7. Validate Binary Search Tree <a href="https://leetcode.com/problems/validate-binary-search-tree/">leetcode 98</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-orgd70f89f">
<ul class="org-ul">
<li>The approach is recursive. The general idea is that each tree returns its own range to its parent. However, if the tree is not a valid Binary Search Tree (BST), then it will return <code>None</code>, instead.</li>
<li>The base case is a terminal tree (leaf node): This is by definition a valid search tree, and its range is just its own value as minimum and maximum.</li>
<li>The recursive case is an intermediate tree (a non-leaf node): If the tree has a left branch, we get the left branch's range:
<ul class="org-ul">
<li>If the returned range is <code>None</code>, then the left tree was invalid: This invalidates also the current tree, so the current tree returns <code>None</code>.</li>
<li>If instead, the returned range is a valid pair of numbers, then we check the relation between the max of the left tree and the own root's value:
<ul class="org-ul">
<li>If the <code>left.max</code> is equal or worst, greater than the root's value, then the BST got just invalidated and we return <code>None</code>.</li>
<li>Otherwise, if <code>left.max</code> is actually strictly less than <code>root.val</code>, then we are good, we just update the minimum on the root's range.</li>
</ul></li>
</ul></li>
<li>The same idea is applied to the right branch of the root.</li>
<li>Eventually, the root will return its own range (or <code>None</code>). And <code>isValidBST()</code> uses that to determine whether the tree is valid or not.</li>
<li>Finally, the problem says that the tree will always have at least one element. But just for the sake of completeness, if somehow <code>isValidBST()</code> receives a <code>root==None</code> tree, I arbitrarily decided that it will be a valid BST.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for a binary tree node.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class TreeNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, left=None, right=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.left = left</span>
<span class="linenr"> 6: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.right = right</span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">class</span> <span class="org-type">Range</span>:
<span class="linenr"> 9: </span>        <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, Min, Max):
<span class="linenr">10: </span>            <span class="org-keyword">self</span>.Min = Min
<span class="linenr">11: </span>            <span class="org-keyword">self</span>.Max = Max
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span class="org-keyword">def</span> <span class="org-function-name">getTreeRange</span>(<span class="org-keyword">self</span>, root: TreeNode) -&gt; Optional[Range]:
<span class="linenr">14: </span>        <span class="org-variable-name">myRange</span> = Range(root.val, root.val)
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">If the left tree exists, then we test for correctness and update myRange</span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">to reflect the minimum of the whole tree.</span>
<span class="linenr">18: </span>        <span class="org-keyword">if</span> root.left != <span class="org-constant">None</span>:
<span class="linenr">19: </span>            <span class="org-variable-name">branchRange</span> = <span class="org-keyword">self</span>.getTreeRange(root.left)
<span class="linenr">20: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">if the left tree was incorrect, or the max of the left tree is equal</span>
<span class="linenr">21: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">or greater than the root's value, then this tree is not a BST</span>
<span class="linenr">22: </span>            <span class="org-keyword">if</span> branchRange == <span class="org-constant">None</span> <span class="org-keyword">or</span> branchRange.Max &gt;= myRange.Min:
<span class="linenr">23: </span>                <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">24: </span>            <span class="org-variable-name">myRange.Min</span> = branchRange.Min
<span class="linenr">25: </span>
<span class="linenr">26: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">Same idea with the right tree</span>
<span class="linenr">27: </span>        <span class="org-keyword">if</span> root.right != <span class="org-constant">None</span>:
<span class="linenr">28: </span>            <span class="org-variable-name">branchRange</span> = <span class="org-keyword">self</span>.getTreeRange(root.right)
<span class="linenr">29: </span>            <span class="org-keyword">if</span> branchRange == <span class="org-constant">None</span> <span class="org-keyword">or</span> branchRange.Min &lt;= myRange.Max:
<span class="linenr">30: </span>                <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">31: </span>            <span class="org-variable-name">myRange.Max</span> = branchRange.Max
<span class="linenr">32: </span>
<span class="linenr">33: </span>        <span class="org-keyword">return</span> myRange
<span class="linenr">34: </span>
<span class="linenr">35: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isValidBST</span>(<span class="org-keyword">self</span>, root: Optional[TreeNode]) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr">36: </span>        <span class="org-keyword">if</span> root == <span class="org-constant">None</span> <span class="org-keyword">or</span> <span class="org-keyword">self</span>.getTreeRange(root) != <span class="org-constant">None</span>:
<span class="linenr">37: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">80ms</td>
<td class="org-right">67%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\): due to the exec. stack</td>
<td class="org-right">17MB</td>
<td class="org-right">14%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org3ceded1" class="outline-3">
<h3 id="org3ceded1"><span class="todo TODO">TODO</span> 6. First Bad Version <a href="https://leetcode.com/problems/first-bad-version/">leetcode 278</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org3ceded1">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org9f08ada" class="outline-3">
<h3 id="org9f08ada"><span class="todo TODO">TODO</span> 5. Binary Search  <a href="https://leetcode.com/problems/binary-search/">leetcode 704</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org9f08ada">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb1c7b30" class="outline-3">
<h3 id="orgb1c7b30"><span class="todo TODO">TODO</span> 4. Binary Tree Level Order Traversal <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode 102</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-orgb1c7b30">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org7baf9bb" class="outline-3">
<h3 id="org7baf9bb"><span class="todo TODO">TODO</span> 3. N-ary Tree Pre-order Traversal <a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">leetcode 589</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org7baf9bb">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1ef3969" class="outline-3">
<h3 id="org1ef3969"><span class="todo TODO">TODO</span> 2. Longest Palindrome <a href="https://leetcode.com/problems/longest-palindrome/">leetcode 409</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org1ef3969">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8fc6c4c" class="outline-3">
<h3 id="org8fc6c4c"><span class="todo CURRENT">CURRENT</span> 1. Best Time to Buy and Sell Stock <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode 121</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org8fc6c4c">
<ul class="org-ul">
<li>&#x2026;</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">ms</td>
<td class="org-right">%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O()\)</td>
<td class="org-right">MB</td>
<td class="org-right">%</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org700dd46" class="outline-2">
<h2 id="org700dd46">Day 1: Let's go!</h2>
<div class="outline-text-2" id="text-org700dd46">
</div>
<div id="outline-container-org091c2e8" class="outline-3">
<h3 id="org091c2e8"><span class="done DONE">DONE</span> 7. Linked List Cycle II <a href="https://leetcode.com/problems/linked-list-cycle-ii">leetcode 142</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-org091c2e8">
<ul class="org-ul">
<li>This Problem uses <a href="https://youcademy.org/floyds-tortise-hare-algorithm/">Floyd's "Tortise and Hare"</a> Cycle finding algorithm.</li>
<li>Basically, we put two pointers "slow" and "fast" at the <b>same</b> location: <code>head</code>.</li>
<li>Slow advances one node at the time, and Fast advances two. (Be careful with de-referencing <code>None</code> pointers).</li>
<li>If there is no loop, then the fast pointer will find that its own <code>next</code> node is <code>None</code>. Fast pointer will see this before the slow pointer.</li>
<li>But, as the algorithm states, if for a second time (the first was in <code>head</code>) slow and fast are in the same spot, then there <b>must</b> be a cycle. It is quite intuitive.</li>
<li>The second part of the algorithm is more interesting, it states that: if you put a pointer <code>p1</code> at the meeting point between fast and slow, and another <code>p2</code> at <code>head</code>, and make both of them advance one node at the time, they will meet at the entrance of the loop. Always!</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, x):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = x</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = None</span>
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 8: </span>    <span class="org-keyword">def</span> <span class="org-function-name">detectCycle</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 9: </span>        <span class="org-variable-name">slow_ptr</span> = <span class="org-variable-name">fast_ptr</span> = head
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">If a pointer reaches None, then the list has an exit, so no loops.</span>
<span class="linenr">12: </span>        <span class="org-keyword">while</span> fast_ptr != <span class="org-constant">None</span> \
<span class="linenr">13: </span>              <span class="org-keyword">and</span> fast_ptr.<span class="org-builtin">next</span> != <span class="org-constant">None</span>:
<span class="linenr">14: </span>            <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">15: </span>            <span class="org-variable-name">fast_ptr</span> = fast_ptr.<span class="org-builtin">next</span>.<span class="org-builtin">next</span>
<span class="linenr">16: </span>
<span class="linenr">17: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">If fast_ptr catches slow_ptr from behind, then there must be a loop.</span>
<span class="linenr">18: </span>            <span class="org-keyword">if</span> slow_ptr == fast_ptr:
<span class="linenr">19: </span>                <span class="org-keyword">break</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">if while loop ended because of end-of-list, then there is no loop.</span>
<span class="linenr">22: </span>        <span class="org-keyword">if</span> fast_ptr == <span class="org-constant">None</span> <span class="org-keyword">or</span> fast_ptr.<span class="org-builtin">next</span> == <span class="org-constant">None</span>:
<span class="linenr">23: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">24: </span>
<span class="linenr">25: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">Otherwise, there is a loop!! Now find the entrance to it.</span>
<span class="linenr">26: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">There is no need to check for None because we already know that</span>
<span class="linenr">27: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">there is no end in this list.</span>
<span class="linenr">28: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">This will not be an infinite loop because of math! the pointers</span>
<span class="linenr">29: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">are guaranteed to meet at the entrance.</span>
<span class="linenr">30: </span>        <span class="org-variable-name">slow_ptr2</span> = head
<span class="linenr">31: </span>        <span class="org-keyword">while</span> slow_ptr != slow_ptr2:
<span class="linenr">32: </span>            <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">33: </span>            <span class="org-variable-name">slow_ptr2</span> = slow_ptr2.<span class="org-builtin">next</span>
<span class="linenr">34: </span>
<span class="linenr">35: </span>        <span class="org-keyword">return</span> slow_ptr
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">58ms</td>
<td class="org-right">88%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">17MB</td>
<td class="org-right">62%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org120c8d6" class="outline-3">
<h3 id="org120c8d6"><span class="done DONE">DONE</span> 6. Middle of the Linked List <a href="https://leetcode.com/problems/middle-of-the-linked-list">leetcode 876</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org120c8d6">
<ul class="org-ul">
<li>In a while loop, I make two pointers run through the list.</li>
<li><code>fast_ptr</code> moves to the next in every loop, and <code>slow_ptr</code> does it only in odd loops (first loop is odd).</li>
<li>It is important to move <code>slow_ptr</code> <b>in odd rather than even loops</b>, because if the list has an even number of elements, moving <code>slow_ptr</code> only in even loops, would give us the first of the two middle nodes.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">middleNode</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 8: </span>        <span class="org-keyword">if</span> head == <span class="org-constant">None</span>:
<span class="linenr"> 9: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">10: </span>        <span class="org-variable-name">slow_ptr</span> = <span class="org-variable-name">fast_ptr</span> = head
<span class="linenr">11: </span>        <span class="org-variable-name">odd_loop</span> = <span class="org-constant">True</span>
<span class="linenr">12: </span>        <span class="org-keyword">while</span> fast_ptr.<span class="org-builtin">next</span> != <span class="org-constant">None</span>:
<span class="linenr">13: </span>            <span class="org-variable-name">fast_ptr</span> = fast_ptr.<span class="org-builtin">next</span>
<span class="linenr">14: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">move slow_ptr only in odd loops</span>
<span class="linenr">15: </span>            <span class="org-keyword">if</span> odd_loop:
<span class="linenr">16: </span>                <span class="org-variable-name">slow_ptr</span> = slow_ptr.<span class="org-builtin">next</span>
<span class="linenr">17: </span>            <span class="org-variable-name">odd_loop</span> = <span class="org-keyword">not</span> odd_loop
<span class="linenr">18: </span>        <span class="org-keyword">return</span> slow_ptr
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">65ms</td>
<td class="org-right">19%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">14MB</td>
<td class="org-right">55%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb171e6e" class="outline-3">
<h3 id="orgb171e6e"><span class="done DONE">DONE</span> 5. Reverse Linked List <a href="https://leetcode.com/problems/reverse-linked-list">leetcode 206</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orgb171e6e">
<ul class="org-ul">
<li>Let's think about the original list as something like this: <code>a--&gt; b--&gt; ... m--&gt; n--&gt; ... --&gt; None</code>.</li>
<li>This list will be divided in two partitions: The Original list (<code>orig_head</code>), and the New list (<code>new_list</code>). The Original will shrink removing one element at the time from its beginning. The New will grow adding one element at the time to its beginning.</li>
<li>At some point the lists will look like this: New: <code>None &lt;--a &lt;--b &lt;--c ... &lt;--m</code>. Original: <code>n--&gt; o--&gt; p--&gt; ... --&gt; None</code>.</li>
<li>Note that the assignment before looping <code>new_head.next = None</code> is to signal the end of the new list.</li>
<li>In the loop, if <code>orig_head</code> is <code>None</code>, this means that we reached the end of the original list, therefore, the reversing is done, and already attached to <code>new_head=</code>.</li>
<li>But if <code>orig_head</code> actually is a node, then we take that node and put it at the beginning of the new list.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">reverseList</span>(<span class="org-keyword">self</span>, head: Optional[ListNode]) -&gt; Optional[ListNode]:
<span class="linenr"> 8: </span>        <span class="org-keyword">if</span> head == <span class="org-constant">None</span>:
<span class="linenr"> 9: </span>            <span class="org-keyword">return</span> <span class="org-constant">None</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>        <span class="org-variable-name">new_head</span> = head
<span class="linenr">12: </span>        <span class="org-variable-name">orig_head</span> = head.<span class="org-builtin">next</span> <span class="org-comment-delimiter"># </span><span class="org-comment">maybe None</span>
<span class="linenr">13: </span>        new_head.<span class="org-builtin">next</span> = <span class="org-constant">None</span> <span class="org-comment-delimiter"># </span><span class="org-comment">the ending of the new list</span>
<span class="linenr">14: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh    h--&gt; ...--&gt; None</span>
<span class="linenr">15: </span>        <span class="org-keyword">while</span> orig_head != <span class="org-constant">None</span>:
<span class="linenr">16: </span>            <span class="org-variable-name">temp_head</span> = orig_head
<span class="linenr">17: </span>            <span class="org-variable-name">orig_head</span> = orig_head.<span class="org-builtin">next</span> <span class="org-comment-delimiter"># </span><span class="org-comment">maybe None</span>
<span class="linenr">18: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh   th--&gt; h--&gt; ...--&gt; None</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span>            temp_head.<span class="org-builtin">next</span> = new_head
<span class="linenr">21: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--nh &lt;--th    h--&gt; ...--&gt; None</span>
<span class="linenr">22: </span>
<span class="linenr">23: </span>            <span class="org-variable-name">new_head</span> = temp_head
<span class="linenr">24: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">None &lt;--?? &lt;--nh    h--&gt; ...--&gt; None</span>
<span class="linenr">25: </span>
<span class="linenr">26: </span>        <span class="org-keyword">return</span> new_head
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">79ms</td>
<td class="org-right">22%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">15.4MB</td>
<td class="org-right">55%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org55560d1" class="outline-3">
<h3 id="org55560d1"><span class="done DONE">DONE</span> 4. Merge Two Sorted Lists <a href="https://leetcode.com/problems/merge-two-sorted-lists">leetcode 21</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org55560d1">
<ol class="org-ol">
<li>Out of the two lists <code>list1</code> and <code>list2</code>, we put the one that starts smallest in <code>list_runner</code>, and the other in <code>list_insert</code>.</li>
<li>We walk through <code>list_runner</code> and stop when the pointer is on
the last element smaller or equal than the one on <code>list_insert</code>.</li>
<li>We create an <code>after_cut</code> pointer to the next one in <code>list_runner</code>, and insert the whole <code>list_insert</code> at <code>list_runner.next</code>.</li>
<li>Now we use <code>list_insert</code> as the new <code>list_runner</code>, and <code>after_cut</code> as the new <code>list_insert</code>.</li>
<li>We repeat the steps from <b>2.</b></li>
<li>Considerations and corner-cases:
<ol class="org-ol">
<li>If one of the lists is empty, then the work is trivial: the other list is the solution.</li>
<li>If we walk to the very end of <code>list_runner</code> (as in step <b>2.</b>), whatever is reminder from <code>list_insert</code>, is appended at the end of <code>list_runner</code></li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="linenr"> 2: </span><span class="org-comment-delimiter"># </span><span class="org-comment">class ListNode:</span>
<span class="linenr"> 3: </span><span class="org-comment-delimiter">#     </span><span class="org-comment">def __init__(self, val=0, next=None):</span>
<span class="linenr"> 4: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.val = val</span>
<span class="linenr"> 5: </span><span class="org-comment-delimiter">#         </span><span class="org-comment">self.next = next</span>
<span class="linenr"> 6: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 7: </span>    <span class="org-keyword">def</span> <span class="org-function-name">mergeTwoLists</span>(<span class="org-keyword">self</span>,
<span class="linenr"> 8: </span>                      list1: Optional[ListNode], \
<span class="linenr"> 9: </span>                      list2: Optional[ListNode]) \
<span class="linenr">10: </span>                      -&gt; Optional[ListNode]:
<span class="linenr">11: </span>        <span class="org-keyword">if</span> list1 == <span class="org-constant">None</span>:
<span class="linenr">12: </span>            <span class="org-keyword">return</span> list2
<span class="linenr">13: </span>        <span class="org-keyword">if</span> list2 == <span class="org-constant">None</span>:
<span class="linenr">14: </span>            <span class="org-keyword">return</span> list1
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">let list1 be the one with the smallest (or equal) starting</span>
<span class="linenr">17: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">value out of the two lists.</span>
<span class="linenr">18: </span>        <span class="org-variable-name">list_runner</span>,<span class="org-variable-name">list_insert</span> = (list1,list2) \
<span class="linenr">19: </span>            <span class="org-keyword">if</span> list1.val &lt; list2.val \
<span class="linenr">20: </span>               <span class="org-keyword">else</span> (list2,list1)
<span class="linenr">21: </span>        <span class="org-variable-name">ans</span> = list_runner
<span class="linenr">22: </span>
<span class="linenr">23: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">breaks when there is nothing else to insert in list_runner.</span>
<span class="linenr">24: </span>        <span class="org-keyword">while</span> list_insert != <span class="org-constant">None</span>:
<span class="linenr">25: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_runner points to its furthest element smaller or equal</span>
<span class="linenr">26: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">than value at list_insert. After this while loop, list_runner</span>
<span class="linenr">27: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">is at the end of its contiguous segment. Between</span>
<span class="linenr">28: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_runner and list_runner.next, a portion of list_insert</span>
<span class="linenr">29: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">will be inserted.</span>
<span class="linenr">30: </span>            <span class="org-keyword">while</span> list_runner.<span class="org-builtin">next</span> != <span class="org-constant">None</span> <span class="org-keyword">and</span> \
<span class="linenr">31: </span>                  list_runner.<span class="org-builtin">next</span>.val &lt;= list_insert.val:
<span class="linenr">32: </span>                <span class="org-variable-name">list_runner</span> = list_runner.<span class="org-builtin">next</span>
<span class="linenr">33: </span>
<span class="linenr">34: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">means that we reached the end of list_runner and still the</span>
<span class="linenr">35: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">last element was smaller or equal than the current in</span>
<span class="linenr">36: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">list_insert. Therefore, we just append the whole list_insert</span>
<span class="linenr">37: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">at the end of list_runner.</span>
<span class="linenr">38: </span>            <span class="org-keyword">if</span> list_runner.<span class="org-builtin">next</span> == <span class="org-constant">None</span>:
<span class="linenr">39: </span>                list_runner.<span class="org-builtin">next</span> = list_insert
<span class="linenr">40: </span>                <span class="org-keyword">break</span>
<span class="linenr">41: </span>
<span class="linenr">42: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;lr&#8213;&#8213;lrac&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">43: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">44: </span>            <span class="org-variable-name">list_runner_after_cut</span> = list_runner.<span class="org-builtin">next</span>
<span class="linenr">45: </span>
<span class="linenr">46: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;lr&#9488; lrac&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">47: </span>            <span class="org-comment-delimiter">#           </span><span class="org-comment">&#9492;&#8213;li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">48: </span>            list_runner.<span class="org-builtin">next</span> = list_insert
<span class="linenr">49: </span>
<span class="linenr">50: </span>            <span class="org-comment-delimiter"># </span><span class="org-comment">&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#9488; li&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">51: </span>            <span class="org-comment-delimiter">#           </span><span class="org-comment">&#9492;&#8213;lr&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;&#8213;</span>
<span class="linenr">52: </span>            <span class="org-variable-name">list_runner</span>,<span class="org-variable-name">list_insert</span> = list_insert,list_runner_after_cut
<span class="linenr">53: </span>
<span class="linenr">54: </span>        <span class="org-keyword">return</span> ans
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">71ms</td>
<td class="org-right">53%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">13.9MB</td>
<td class="org-right">80%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org071bc12" class="outline-3">
<h3 id="org071bc12"><span class="done DONE">DONE</span> 3. Is Sub-sequence <a href="https://leetcode.com/problems/is-subsequence/">leetcode 392</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org071bc12">
<ul class="org-ul">
<li><del>Here I am thinking that if many sub-sequences <code>s</code> are going to be searched in the same <code>t</code> then it may be a good idea to make a dictionary with "the first occurrence of each character of <code>t</code>", then, each subsequent search would be just checking that the indices obtained from the dictionary go in ascending order&#x2026; hold on&#x2026; This does not handle repetitions. Scratch that.</del></li>
<li>I will grab the first char of the sub-sequence candidate <code>s</code>, and start traversing <code>t</code>. If I find my character, then I grab the next one in <code>s</code>, and keep searching starting from the very next one in <code>t</code>.</li>
<li>There are some special cases:
<ul class="org-ul">
<li>If <code>s</code> is empty, then it is always a sub-sequence.</li>
<li>If <code>t</code> is empty, then only <code>s=""</code> is sub-sequence.</li>
<li>If <code>len(s)&gt;len(t)</code>, then <code>s</code> cannot be sub-sequence of <code>t</code>.</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isSubsequence</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr"> 3: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">corner cases</span>
<span class="linenr"> 4: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(s) == 0:
<span class="linenr"> 5: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
<span class="linenr"> 6: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t) &lt; <span class="org-builtin">len</span>(s):
<span class="linenr"> 7: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">to indices traverse s and t</span>
<span class="linenr">10: </span>        <span class="org-variable-name">i</span>, <span class="org-variable-name">j</span> = 0, 0
<span class="linenr">11: </span>        <span class="org-keyword">while</span> (i &lt; <span class="org-builtin">len</span>(s) <span class="org-keyword">and</span> j &lt; <span class="org-builtin">len</span>(t)):
<span class="linenr">12: </span>            <span class="org-keyword">if</span> (s[i] == t[j]):
<span class="linenr">13: </span>                <span class="org-variable-name">i</span> += 1
<span class="linenr">14: </span>            <span class="org-variable-name">j</span> += 1
<span class="linenr">15: </span>
<span class="linenr">16: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">check if the s was totally covered</span>
<span class="linenr">17: </span>        <span class="org-keyword">if</span> (i == <span class="org-builtin">len</span>(s)):
<span class="linenr">18: </span>            <span class="org-keyword">return</span> <span class="org-constant">True</span>
<span class="linenr">19: </span>        <span class="org-keyword">else</span>:
<span class="linenr">20: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">35ms</td>
<td class="org-right">92%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">13.9MB</td>
<td class="org-right">82%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org3e62e8e" class="outline-3">
<h3 id="org3e62e8e"><span class="done DONE">DONE</span> 2. Isomorphic Strings <a href="https://leetcode.com/problems/isomorphic-strings/">leetcode 205</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org3e62e8e">
<ul class="org-ul">
<li>Here I am using a "bilingual" dictionary (<code>forward_dict</code> for \(s \rightarrow t\), and <code>backward_dict</code> for \(t \rightarrow s\).</li>
<li>The idea is that if a character <code>si</code> maps to <code>ti</code> in <code>forward_dict</code>, then <code>backward_dict</code> must have a mapping from <code>ti</code> to <code>si</code>, and vice versa.</li>
<li>If a mapping is not found, and because it is factual that <code>si</code> \(\leftrightarrow\) <code>ti</code>, then each mapping is added to its corresponding dictionary.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">isIsomorphic</span>(<span class="org-keyword">self</span>, s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">forward_dict</span> = {}
<span class="linenr"> 4: </span>        <span class="org-variable-name">backward_dict</span> = {}
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">diff lenghth breaks isomorphism.</span>
<span class="linenr"> 7: </span>        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(s) != <span class="org-builtin">len</span>(t):
<span class="linenr"> 8: </span>            <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>        <span class="org-comment-delimiter"># </span><span class="org-comment">It must be that: si -&gt; ti and ti -&gt; si</span>
<span class="linenr">11: </span>        <span class="org-keyword">for</span> si,ti <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(s,t):
<span class="linenr">12: </span>            <span class="org-keyword">if</span> si <span class="org-keyword">in</span> forward_dict:
<span class="linenr">13: </span>                <span class="org-comment-delimiter"># </span><span class="org-comment">if si-&gt;tj, then si-&gt;ti and si-&gt;tj; not isomorphic</span>
<span class="linenr">14: </span>                <span class="org-keyword">if</span> forward_dict[si] != ti:
<span class="linenr">15: </span>                    <span class="org-keyword">return</span> <span class="org-constant">False</span>
<span class="linenr">16: </span>            <span class="org-keyword">else</span>:
<span class="linenr">17: </span>                <span class="org-variable-name">forward_dict</span>[si] = ti
<span class="linenr">18: </span>
<span class="linenr">19: </span>            <span class="org-keyword">if</span> ti <span class="org-keyword">in</span> backward_dict:
<span class="linenr">20: </span>                <span class="org-keyword">if</span> backward_dict[ti] != si:
<span class="linenr">21: </span>                    <span class="org-keyword">return</span> <span class="org-constant">False</span>  
<span class="linenr">22: </span>            <span class="org-keyword">else</span>:
<span class="linenr">23: </span>                <span class="org-variable-name">backward_dict</span>[ti] = si
<span class="linenr">24: </span>        <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">83ms</td>
<td class="org-right">47%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">14.3MB</td>
<td class="org-right">46%</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8fa3667" class="outline-3">
<h3 id="org8fa3667"><span class="done DONE">DONE</span> 1. Find Pivot Index <a href="https://leetcode.com/problems/find-pivot-index/">leetcode 724</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-org8fa3667">
<ul class="org-ul">
<li>An idea that leads to \(O(n)\) is to add-up everything in a variable <code>total</code>, so we know what is the total sum of the whole array <code>nums</code>.</li>
<li>Then, go back to the beginning and traverse one by one and carrying a <code>left_sum</code> initialized in 0 .</li>
<li>In each iteration, I compute <code>right_sum = total - left_sum - nums[i]</code> and check if <code>left_sum</code> is equal to <code>right_sum</code>.</li>
<li>If they are equal, I return the index. If not, the pivot candidate <code>arr[i]</code> is added to <code>left_sum</code>.</li>
<li>The numbers can be negative, so even if <code>left_sum</code> becomes bigger than <code>right_sum</code>, there is still a chance of going back to a balanced state.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="linenr"> 1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr"> 2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">pivotIndex</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
<span class="linenr"> 3: </span>        <span class="org-variable-name">total</span> = <span class="org-builtin">sum</span>(nums)
<span class="linenr"> 4: </span>        <span class="org-variable-name">left_sum</span> = 0
<span class="linenr"> 5: </span>        <span class="org-keyword">for</span> i,piv <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(nums):
<span class="linenr"> 6: </span>            <span class="org-variable-name">right_sum</span> = total - left_sum - piv
<span class="linenr"> 7: </span>            <span class="org-keyword">if</span> left_sum == right_sum:
<span class="linenr"> 8: </span>                <span class="org-keyword">return</span> i
<span class="linenr"> 9: </span>            <span class="org-variable-name">left_sum</span> += piv
<span class="linenr">10: </span>        <span class="org-keyword">return</span> -1
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">396ms</td>
<td class="org-right">27%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(1)\)</td>
<td class="org-right">15.2MB</td>
<td class="org-right">92%</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgf50677c" class="outline-2">
<h2 id="orgf50677c">Day 0: Get your lazy ass started!</h2>
<div class="outline-text-2" id="text-orgf50677c">
</div>
<div id="outline-container-orge17a53d" class="outline-3">
<h3 id="orge17a53d"><span class="done DONE">DONE</span> 1. Running Sum of 1d Array <a href="https://leetcode.com/problems/running-sum-of-1d-array/">leetcode 1480</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-orge17a53d">
<ul class="org-ul">
<li>Easy warm-up, carry the sum in a variable <code>last_sum</code>, and in every iteration, put its current value in the array to return.</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span class="org-keyword">class</span> <span class="org-type">Solution</span>:
<span class="linenr">2: </span>    <span class="org-keyword">def</span> <span class="org-function-name">runningSum</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>]) -&gt; List[<span class="org-builtin">int</span>]:
<span class="linenr">3: </span>        <span class="org-variable-name">rsum</span> = []
<span class="linenr">4: </span>        <span class="org-variable-name">last_sum</span> = 0
<span class="linenr">5: </span>        <span class="org-keyword">for</span> x <span class="org-keyword">in</span> nums:
<span class="linenr">6: </span>            <span class="org-variable-name">last_sum</span> += x
<span class="linenr">7: </span>            rsum.append(last_sum)
<span class="linenr">8: </span>        <span class="org-keyword">return</span> rsum
</pre>
</div>
<table class="bench">


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Runtime</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">84ms</td>
<td class="org-right">34%</td>
<td class="org-left"><b>Memory</b></td>
<td class="org-left">\(O(n)\)</td>
<td class="org-right">14.2MB</td>
<td class="org-right">28%</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Claudio A. Parra</p>
<p class="email">Email: <a href="mailto:onlycparra at gm*il d0t c*m">onlycparra at gm*il d0t c*m</a></p>
<p class="date">Created: 2022-11-01 Tue 00:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
